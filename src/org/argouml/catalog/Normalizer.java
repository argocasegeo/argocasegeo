/*
 *  Normalizer.java
 *  
 *  Alexandre Gazola 
 *  Criado em 25/07/2005
 *  �ltima atualiza��o em 19/01/2006
 * 
 *  Projeto Final de Curso
 *  Desenvolvimento do Cat�logo de Padr�es de An�lise da
 *  Ferramenta CASE ArgoCASEGEO
 *  
 */
package org.argouml.catalog;

import javax.xml.parsers.*;

import org.w3c.dom.*;

import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;

/**
 * Esta classe cont�m fun��es utilit�rias para o tratamento
 * dos arquivos de projeto (.zargo, .xmi e .pgml), bem como
 * as principais fun��es necess�rias para realizar o processo
 * de reutiliza��o de esquemas conceituais de dados geogr�ficos.
 * 
 * @author Alexandre Gazola
 *
 */
public class Normalizer {

    /**
     * Caminho do arquivo XML
     */
    private String xmlPathName;
    /*
     * As demais vari�veis comp�em o parser
     */
    private DocumentBuilderFactory dbf;
    private DocumentBuilder db;
    private Document doc;

    /**
     * Realiza a "normaliza��o de um arquivo", que consiste
     * em substituir os ID�s de um determinado arquivo para
     * prepar�-lo para a importa��o
     * @param path Caminho do arquivo a ser "normalizado"
     * @throws Exception
     */
    public void setNormal(String path) throws Exception {
        xmlPathName = path;
        try {
            dbf = DocumentBuilderFactory.newInstance();
            db = dbf.newDocumentBuilder();
            doc = db.parse(xmlPathName);

        } catch (Exception e) {
            System.out.println("exce�ao aqui!" + e);
        }

        // obt�m raiz do documento XML
        Element elem = doc.getDocumentElement();

        // pega todos os Modelos do XML, os quais representar�o bancos de dados
        // diferentes
        NodeList nl = elem.getElementsByTagName("Model_Management.Model");

        // obtem modelo
        Element model = (Element) nl.item(0);

        NodeList packages = model.getElementsByTagName("Model_Management.Package");

        for (int npack = 0; npack < packages.getLength(); npack++) {

            Element pack = (Element) packages.item(npack);

            pack.setAttribute("xmi.id", "xmi.50");

            break;
        }
    }

    /**
     * Cria um arquivo XML
     * @param saida Arquivo XML gerado
     */
    public void generateXml(String saida) {
        Transformer transformer = null;
        try {

            // Use a Transformer for output
            TransformerFactory tFactory = TransformerFactory.newInstance();
            transformer = tFactory.newTransformer();

            DOMSource source = new DOMSource(doc);
            StreamResult result = new StreamResult(new File(saida));//System.out);
            transformer.transform(source, result);
        } catch (TransformerConfigurationException tce) {
            // Error generated by the parser
            System.out.println("* Transformer Factory error");
            System.out.println("  " + tce.getMessage());

            // Use the contained exception, if any
            Throwable x = tce;
            if (tce.getException() != null) {
                x = tce.getException();
            }
            x.printStackTrace();
        } catch (TransformerException te) {
            // Error generated by the parser
            System.out.println("* Transformation error");
            System.out.println("  " + te.getMessage());

            // Use the contained exception, if any
            Throwable x = te;
            if (te.getException() != null) {
                x = te.getException();
            }
            x.printStackTrace();

        } catch (Exception spe) {
            if (doc.getDoctype() != null) {
                String systemValue = (new File(doc.getDoctype().getSystemId())).getName();
                transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM,
                        systemValue);
            }
        }
    }

    /**
     * Substitui arquivo .xmi antigo por novo
     * @param fInput Arquivo .xmi antigo
     * @param fOutput Arquivo .xmi novo
     */
    public void replaceXmi(String fInput, String fOutput) {
        File fIn = new File(fInput);
        File fOut = new File(fOutput);

        try {
            FileReader reader = new FileReader(fIn);
            BufferedReader leitor = new BufferedReader(reader);

            FileWriter writer = new FileWriter(fOut);
            PrintWriter saida = new PrintWriter(writer, true);

            String line = null;
            // pra nao dar conflito entre os 'id's dos dois padroes:
            // o atual e o reutilizado... adiciona o '100' na frente.
            String subId = "xmi.id=\"xmi.100";
            String subIdref = "xmi.idref=\"xmi.100";


            line = leitor.readLine();
            String temp = null;

            while (line != null) {

                temp = line.replaceAll("xmi.id=\"xmi.", subId);
                temp = temp.replaceAll("xmi.idref=\"xmi.", subIdref);

                // grava no arquivo
                saida.println(temp);

                line = leitor.readLine();

            }

        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * Substitui arquivo .pgml antigo por novo
     * @param fInput Arquivo .pgml antigo
     * @param fOutput Arquivo .pgml novo
     */
    public void replacePgml(String fInput, String fOutput) {


        File fIn = new File(fInput);
        File fOut = new File(fOutput);

        try {
            FileReader reader = new FileReader(fIn);
            BufferedReader leitor = new BufferedReader(reader);

            FileWriter writer = new FileWriter(fOut);
            PrintWriter saida = new PrintWriter(writer, true);


            String line = null;
            // colocar generico
            // Fig'100' para nao dar conflito com os anteriores
            // usando POG :D
            String fig = "Fig100";

            String figImage = "FigImage";
            String figGroup = "FigGroup";
            String figGeo = "FigGeo";
            String figNo = "FigNo";
            String figPack = "FigPackage";
            String figAssociation = "FigAssociation";
            String enclosingFig = "enclosingFig";
            String sourcePortFig = "sourcePortFig";
            String destPortFig = "destPortFig";
            String figPoly = "FigPoly";
            String figGeneralization = "FigGeneralization";

            line = leitor.readLine();
            String temp = null;

            //boolean enters = true;
            while (line != null) {

                temp = line.replaceAll("Fig", fig);
                temp = temp.replaceAll("Fig100Image", figImage);
                temp = temp.replaceAll("Fig100Group", figGroup);
                temp = temp.replaceAll("Fig100Geo", figGeo);
                temp = temp.replaceAll("Fig100No", figNo);
                temp = temp.replaceAll("Fig100Package", figPack);
                temp = temp.replaceAll("Fig100Association", figAssociation);
                temp = temp.replaceAll("enclosingFig100", enclosingFig);
                temp = temp.replaceAll("sourcePortFig100", sourcePortFig);
                temp = temp.replaceAll("destPortFig100", destPortFig);
                temp = temp.replaceAll("Fig100Poly", figPoly);
                temp = temp.replaceAll("Fig100Generalization", figGeneralization);
                /*if (enters && temp.contains("FigPackage")) {
                enters = false;
                String localizacao = null;
                String[] numbers = {"", "", "", ""};

                System.out.println("legal legal!");
                localizacao = temp.substring(75);

                char c = localizacao.charAt(0);
                int cont = 0;
                int index = 0;
                outer:
                while (c != ']') {
                while (c != ',') {
                numbers[cont] += c;
                index++;
                c = localizacao.charAt(index);
                if (c == ']')
                break outer;
                }
                cont++;
                index++;
                c = localizacao.charAt(index);
                }

                int deslocamento = 0;
                deslocamento = (Integer.parseInt(numbers[2].trim()) -
                Integer.parseInt(numbers[0].trim()));
                int primeiraCord = (Integer.parseInt(numbers[0].trim())
                + deslocamento);
                numbers[0] = Integer.toString(primeiraCord);

                String novaString = temp.substring(0, 75);
                novaString += Integer.toString(primeiraCord) +
                ", " + numbers[1] + ", " + numbers[2] + ", " +
                numbers[3] + "]";

                System.out.println("veja q maravilha: "
                + novaString);

                saida.println(novaString);
                line = leitor.readLine();
                continue;
                }*/




                saida.println(temp);
                line = leitor.readLine();
            }

        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * Realiza a jun��o de dois esquemas .xmi
     * @param xmi1 Primeiro arquivo .xmi
     * @param xmi2 Segundo arquivo .xmi
     * @param dest Arquivo gerado (jun��o dos dois arquivos .xmi)
     */
    public void mergeXmi(String xmi1, String xmi2, String dest) throws Exception{
        DocumentBuilder db2 = null;
        Document docPattern = null;

        try {
            dbf = DocumentBuilderFactory.newInstance();
            db = dbf.newDocumentBuilder();
            doc = db.parse(xmi1);
            db2 = dbf.newDocumentBuilder();
            docPattern = db.parse(xmi2);

        } catch (Exception e) {
            System.out.println("exce�ao aqui!" + e);
            throw e;
            
        }

        Element elem = doc.getDocumentElement();
        NodeList nl = null;
        if (elem != null) {
            nl = elem.getElementsByTagName("Foundation.Core.Namespace.ownedElement");
        }
        // obtem elemento que cont�m o que o modelo possui
        Element model = null;
        if (nl != null) {
            model = (Element) nl.item(0);
        }


        // obt�m raiz do documento XML (padr�o)
        Element elemPattern = null;
        if (docPattern != null) {
            elemPattern = docPattern.getDocumentElement();
        }
        // obt�m pacotes do padr�o
        NodeList nlPattern = null;
        if (elemPattern != null) {
            nlPattern = elemPattern.getElementsByTagName("Model_Management.Package");
        }

        // acrescenta os pacotes do padr�o ao modelo atual
        if (nlPattern != null && model != null) {
            for (int i = 0; i < nlPattern.getLength(); i++) {
                model.appendChild(doc.importNode(nlPattern.item(i), true));
            }
        }
        if (elemPattern != null) {
            nlPattern = elemPattern.getElementsByTagName("Foundation.Core.DataType");
        }

        // acrescenta os tipos de dados do padr�o ao modelo atual
        if (nlPattern != null && model != null) {
            for (int i = 0; i < nlPattern.getLength(); i++) {
                model.appendChild(doc.importNode(nlPattern.item(i), true));
            }
        }
        if (elemPattern != null) {
            nlPattern = elemPattern.getElementsByTagName("Foundation.Core.Class");
        }

        // acrescenta os tipos de dados derivados do padr�o ao modelo atual
        if (nlPattern != null && model != null) {
            for (int i = 0; i < nlPattern.getLength(); i++) {
                model.appendChild(doc.importNode(nlPattern.item(i), true));
            }
        }

        this.generateXml(dest);

    }

    /**
     * Realiza a jun��o de dois esquemas .pgml
     * @param xmi1 Primeiro arquivo .pgml
     * @param xmi2 Segundo arquivo .pgml
     * @param dest Arquivo gerado (jun��o dos dois arquivos .pgml)
     */
    public void mergePgml(String pgml1, String pgml2, String dest) {
        DocumentBuilder db2 = null;
        Document docPattern = null;

        try {
            dbf = DocumentBuilderFactory.newInstance();
            dbf.setValidating(false);
            db = dbf.newDocumentBuilder();
            doc = db.parse(pgml1); // aqui nao acha dtd
        } catch (Exception e) {
            System.out.println("exce�ao aqui22!" + e);
        }
        try {
            db2 = dbf.newDocumentBuilder();
            docPattern = db.parse(pgml2);
        } catch (Exception e) {
            System.out.println("exce�ao aqui111!" + e);
        }

        Element elem = doc.getDocumentElement();
        NodeList nl = elem.getElementsByTagName("pgml");

        // obt�m raiz do documento XML (padr�o)
        Element elemPattern = docPattern.getDocumentElement();
        // obt�m pacotes do padr�o
        NodeList nlPattern = elemPattern.getElementsByTagName("group");

        for (int i = 0; i < nlPattern.getLength(); i++) {
            elem.appendChild(doc.importNode(nlPattern.item(i), true));

        }

        this.generateXml(dest);
    }

    /**
     * L� e retorna o conte�do (texto) de uma tag (elemento)
     * filho da tag informada como par�metro. A tag filho a ser pesquisada
     * � a tag informada pelo nome (string)
     * @param elem Tag
     * @param tagName Tag filho
     * @return Retorna o conte�do da tag
     * @throws Exception
     */
    public static String getChildTagValue(Element elem, String tagName) throws Exception { // voltar para private depois
        NodeList children = elem.getElementsByTagName(tagName);
        if (children == null) {
            return null;
        }
        Element child = (Element) children.item(0);
        if (child == null) {
            return null;
        }
        return child.getFirstChild().getNodeValue();
    }
}
